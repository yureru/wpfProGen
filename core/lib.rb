# generator lib
module Lib
  # finds the number of tabs (each "tab" being 4 spaces) of the starting region.
  def Lib.numberOfTabs(str, regex)
    nstr = str[regex, 1]
    len = nstr.length
    tabsNum = len / 4
    return tabsNum
  end
  # makes the first char of a string to downcase, and prepends an underscore.
  def Lib.uncapitalizeFirstChar(str)
      nstr = str[0, 1].downcase + str[1..-1]
      nstr = "_" + nstr
      return nstr
  end
  # creates a level of indent based on levels, and indent is four spaces.
  def Lib.levelsOfIndent(levels)
    indent = levels * 4;
    str = ""
    indent.times do
      str += " "
    end
    return str
  end

  # used to set/get the starting level of the indent, should be setted by
  # numberOfTabs function.
  module_function
  @@isl
  def indentStartingLevel; @@isl end
  def indentStartingLevel= v; @@isl = v end

# Creates each property and member
def Lib.createProperty(property)
    # could check if length == 4 to validate
    clrProperty = ""
    accessModifier = ""
    staticMod = ""
    if (property[0])
      accessModifier = "public "
    end
    if (property[1])
      staticMod = "static "
    end
    typeOf = property[2]
    nameOfProperty = property[3]
    backfield = Lib.uncapitalizeFirstChar(nameOfProperty)

    indentl1 = Lib.levelsOfIndent(Lib.indentStartingLevel)
    indentl2 = Lib.levelsOfIndent(Lib.indentStartingLevel + 1)
    indentl3 = Lib.levelsOfIndent(Lib.indentStartingLevel + 2)
    indentl4 = Lib.levelsOfIndent(Lib.indentStartingLevel + 3)

    # creates CLR property
    stringFormatter = indentl1 + "#{accessModifier}#{staticMod}#{typeOf} #{nameOfProperty}\n" +
    indentl1 + "{\n" +
    indentl2 + "get { return #{backfield}; }" + "\n" +
    indentl2 + "set" + "\n" +
    indentl2 + "{\n" +
    indentl3 + "if (#{backfield} == value)" + "\n" +
    indentl3 + "{\n" +
    indentl4 + "return;" + "\n" +
    indentl3 + "}" + "\n" +
    indentl3 + "#{backfield} = value;" + "\n" +
    indentl3 + "OnPropertyChanged(\"#{nameOfProperty}\");" + "\n" +
    indentl2 + "}\n" +
    indentl1 + "}\n\n"

    propertyAndBackfield = Array.new(2)
    propertyAndBackfield[0] = stringFormatter

    # creates the backing field
    propertyAndBackfield[1] = indentl1 + "#{staticMod}#{typeOf} #{backfield};\n\n"

    return propertyAndBackfield
  end
	
  # Region comments
  BeginMembersRegion    = '#region Autogenerated Members'
  EndMembersRegion      = '#endregion // Autogenerated Members'
  BeginPropertiesRegion = '#region Autogenerated Properties'
  EndPropertiesRegion   = '#endregion // Autogenerated Properties'

  # Regular Expressions
  # Used to find the indent level based on the properties region
  RegTabIndentationStart = Regexp.new('^(.+?)' + Lib::BeginPropertiesRegion)
  # Match the region for the Properties
  RegPropertiesRegion = Regexp.new(Lib::BeginPropertiesRegion + '(.*?)' + Lib::EndPropertiesRegion, Regexp::MULTILINE)
  # Match the region for the Members
  RegMembersRegion = Regexp.new(Lib::BeginMembersRegion + '(.*?)' + Lib::EndMembersRegion, Regexp::MULTILINE)
  # Finds the filename with extension
  RegFilename = /([^\/]+)(?=\.([0-9a-z]+)(?:[\?#]|$))/
  # Finds the path of a file
  RegPath = /(.*?\/)[^\/]*?\.\S*/
  

end