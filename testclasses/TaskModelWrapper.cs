using easytodo.DataAccess;
using easytodo.Helper_Classes;
using easytodo.Properties;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Timers;
using System.Windows;
using System.Windows.Input;

namespace easytodo.Model
{
    class TaskModelWrapper : ObservableObject, IDataErrorInfo, IMainButton
    {

        #region Members
        // ©
        readonly TaskModel _task;
        static TaskRepository _repository;

        // TODO: Delete this timer.
        Timer _timer;
        static TaskModelWrapper _current;
        static bool _taskHasStarted;
        static ObservableCollection<TaskModelWrapper> _currentTask = new ObservableCollection<TaskModelWrapper>();
        string _timerVisible = Resources.Visibility_Collapsed;
        bool _taskPaused;

        // Commands
        RelayCommand _saveCommand;
        RelayCommand _startOrPauseCommand;
        RelayCommand _editCommand;
        RelayCommand _deleteCommand;
        RelayCommand _completeCommand;


        string _priority;
        string _playOrPauseIsVisible = Resources.Visibility_Visible;

        #endregion // Members

        #region Autogenerated Members

        #endregion // Autogenerated Members

        #region Autogenerated Properties

        #endregion // Autogenerated Properties

        #region Model Properties

        public int ID
        {
            get { return _task.ID; }
            set
            {
                if (_task.ID == value)
                {
                    return;
                }

                _task.ID = value;
                OnPropertyChanged("ID");
            }
        }
        public string Name
        {
            get { return _task.Name; }
            set
            {
                if (_task.Name == value)
                {
                    return;
                }

                _task.Name = value;
                OnPropertyChanged("Name");
            }
        }
        public string Content
        {
            get { return _task.Content; }
            set
            {
                if (_task.Content == value)
                {
                    return;
                }

                _task.Content = value;
                OnPropertyChanged("Content");
            }
        }
        
        public int Pomodoros
        {
            get { return _task.Pomodoros; }
            set
            {
                if (_task.Pomodoros == value)
                {
                    return;
                }

                _task.Pomodoros = value;
                OnPropertyChanged("Pomodoros");
            }
        }
        /// TODO: Implement creation date and due date.
        public bool IsBookmark
        {
            get { return _task.IsBookmark; }
            set
            {
                if (_task.IsBookmark == value)
                {
                    return;
                }

                _task.IsBookmark = value;
                OnPropertyChanged("IsBookmark");
            }
        }

        public string PlayPauseIsVisible
        {
            get { return _playOrPauseIsVisible; }
            set
            {
                if (_playOrPauseIsVisible == value)
                {
                    return;
                }

                _playOrPauseIsVisible = value;
                OnPropertyChanged("PlayPauseIsVisible");
            }

        }

        public string Category
        {
            get { return _task.Category; }
            set
            {
                if (_task.Category == value)
                {
                    return;
                }
                _task.Category = value;
                OnPropertyChanged("Category");
            }

        }

        public ObservableCollection<string> CategoriesItems
        {
            get { return _repository.Categories; }
            set { }
        }

        public string Priority
        {
            get { return _priority; }
            set
            {
                var e = (TaskModel.Priority)Enum.Parse(typeof(TaskModel.Priority), value, true);

                _priority = value;
                OnPropertyChanged("Priority");
                _task.TaskPriority = e;
                OnPropertyChanged("TaskPriority");
            }
        }

        public TaskModel.Priority TaskPriority
        {
            get { return _task.TaskPriority; }
            set
            {
                if (_task.TaskPriority == value)
                {
                    return;
                }

                _task.TaskPriority = value;
                OnPropertyChanged("TaskPriority");
            }
        }

        public string[] TaskPriorityItems
        {
            get
            {
                // TODO: Add a enum utility class
                var itmEnum = Enum.GetValues(typeof(TaskModel.Priority));
                var items = new string[itmEnum.Length];

                int index = 0;
                foreach (var i in itmEnum)
                {
                    items[index] = i.ToString();
                    ++index;
                }

                return items;
            }
        }

        public TaskModelWrapper Current
        {
            get { return _current; }

            set
            {
                if (_current == value)
                {
                    return;
                }

                _current = value;
                OnPropertyChanged("Current");
            }
        }

        public static ObservableCollection<TaskModelWrapper> CurrentTask
        {
            get { return _currentTask; }
            set { }
        }

        public bool TaskHasStarted
        {
            get { return _taskHasStarted; }
            set
            {
                if (_taskHasStarted == value)
                {
                    return;
                }

                _taskHasStarted = value;
                OnPropertyChanged("TaskHasStarted");
            }
        }

        public bool TaskPaused
        {
            get { return _taskPaused; }
            set
            {
                if (_taskPaused == value)
                {
                    return;
                }

                _taskPaused = value;
                OnPropertyChanged("TaskPaused");
            }
        }

        /// <summary>
        /// Used to show the visibility of the Timer and the Finish button.
        /// </summary>
        public string TimerVisible
        {
            get { return _timerVisible; }
            set
            {
                if (_timerVisible == value)
                {
                    return;
                }

                _timerVisible = value;
                OnPropertyChanged("TimerVisible");
            }
        }

        public string Timer
        {
            get { return TaskTimer.CurrentTime; }
            set
            {
                OnPropertyChanged("Timer");
            }
        }

        #endregion // Model Properties

        #region Constructors

        private TaskModelWrapper() { }

        public TaskModelWrapper(TaskModel task, TaskRepository repository)
        {
            if (task == null)
            {
                throw new ArgumentNullException(Resources.Error_Exception_TaskCantBeNull);
            }

            _task = task;
            _repository = repository;
            SetComboboxToDefault();

            TaskTimer.AddEventHandler((sender, e) => FetchTimer(), true);
        }

        public TaskModelWrapper(TaskModel task)
        {
            _task = task;
        }

        #endregion // Constructors

        #region Commands

        /// <summary>
        /// Returns a command that saves the task.
        /// </summary>
        public ICommand SaveCommand
        {
            get
            {
                if (_saveCommand == null)
                {
                    _saveCommand = new RelayCommand(
                        param => this.Save(),
                        param => this.CanSave()
                        );
                }
                return _saveCommand;
            }
        }

        /// <summary>
        /// Command to start or pause a task and therefore the Timer of the task.
        /// </summary>
        public ICommand StartOrPauseCommand
        {
            get
            {
                if (_startOrPauseCommand == null)
                {
                    _startOrPauseCommand = new RelayCommand(
                        param => this.StartOrPause(param),
                        param => this.CanStartOrPause(param)
                        );
                }

                return _startOrPauseCommand;
            }
        }

        /// <summary>
        /// Command to edit the given task.
        /// </summary>
        public ICommand EditCommand
        {

            get
            {
                if (_editCommand == null)
                {
                    _editCommand = new RelayCommand(
                        param => this.Edit(param),
                        param => this.CanEdit()
                        );
                }

                return _editCommand;
            }
        }

        /// <summary>
        /// Command to delete the given task.
        /// </summary>
        public ICommand DeleteCommand
        {
            get
            {
                if (_deleteCommand == null)
                {
                    _deleteCommand = new RelayCommand(
                        param => this.Delete(param),
                        param => this.CanDelete()
                        );
                }

                return _deleteCommand;
            }
        }

        /// <summary>
        /// Command to specify the given task has been completed.
        /// </summary>
        public ICommand CompleteCommand
        {
            get
            {
                if (_completeCommand == null)
                {
                    _completeCommand = new RelayCommand(
                        param => this.Complete(param),
                        param => this.CanComplete()
                        );
                }
                return _completeCommand;
            }
        }

        #endregion // Commands

        #region Methods

        /// <summary>
        /// Create a new TasModelWrapper object and copies the fields from a TaskModel.
        /// </summary>
        /// <param name="from">TaskModel to be copied from.</param>
        /// <returns>A new TaskModelWrapper.</returns>
        public static TaskModelWrapper Copy(TaskModel from)
        {
            var to = new TaskModelWrapper();
            to.ID = from.ID;
            to.Name = from.Name;
            to.Content = from.Content;
            to.Category = from.Category;
            to.Pomodoros = from.Pomodoros;
            to.IsBookmark = from.IsBookmark;
            to.TaskPriority = from.TaskPriority;

            return to;
        }

        

        #endregion // Methods

        #region Helper Methods

        /// <summary>
        /// Saves a task. Currently only saves new ones, but later here we will allow to save the editing ones.
        /// </summary>
        void Save()
        {
            var item = TaskModel.Copy(_task);
            _repository.AddEmployee(item);
            // For testing purposes
            MessageBox.Show(this.ToString() + "\n Number of items in collection is: " + _repository.GetCollection().Count);
        }

        bool CanSave()
        {
            return true;
        }

        /// <summary>
        /// Starts or pause the task that asked for this operation.
        /// </summary>
        /// <param name="task">Task to start / stop.</param>
        void StartOrPause(object task)
        {
            var t = task as TaskModelWrapper;
            if (t == null)
            {
                // TODO: String resources
                throw new ArgumentException(Resources.Error_Exception_TaskCantBeNull);
            }

            ToggleStartPause(t);
        }

        /// <summary>
        /// Checks if we can start / stop that given task.
        /// That can only happen if there isn't a task currently running, or the current task is stopped.
        /// </summary>
        /// <param name="task">Task to start / stop.</param>
        /// <returns>True if allows the operation, false otherwise.</returns>
        bool CanStartOrPause(object task)
        {
            var t = task as TaskModelWrapper;
            if (t == null)
            {
                // Must return (and not throw) if t is null since a binding.
                return false;
            }
            // Allow only if _currentTask is empty, the task to be start/stop is the same as the current, 
            // or the task has been paused (note that compares to false since that's how CheckBox's IsChecked binding works.
            if (_currentTask.Count == 0 || _currentTask[0] == t || _currentTask[0].TaskPaused == false)
            {
                return true;
            }
            else
            {
                t.TaskPaused = false; // Toggle back to false to avoid checkbox's change due binding.
                return false;
            }
        }

        void Edit(object id)
        {
            var cid = (int)id;
            // Test purposes
            TestDialog("Edit method, ID is: " + cid);
        }

        bool CanEdit()
        {
            // Later we should decide when we can and can't edit a task.
            return true;
        }

        void Delete(object id)
        {
            var cid = (int)id;
            // Test purposes.
            TestDialog("Delete method, ID is: " + cid);
        }

        bool CanDelete()
        {
            /* When we can delete a task:
             * 1. If the task is not running currently.
             */
            return true;
        }

        /// <summary>
        /// Completes the currently running task.
        /// </summary>
        /// <param name="id"></param>
        void Complete(object id)
        {
            var t = id.GetType();
            TestDialog(t.ToString());
        }

        bool CanComplete()
        {
            // Restrict to "Can complete only the running task, doesn't matters if is currently started or stopped, needs to be the current one."
            return TaskHasStarted;
        }

        /// <summary>
        /// Sets the given task to the current one and start / stops it including the timer.
        /// </summary>
        /// <param name="t">The task selected.</param>
        void ToggleStartPause(TaskModelWrapper t)
        {
            // Hides the timer for the old task.
            if (TaskHasStarted && Current != t)
            {
                Current.TimerVisible = Resources.Visibility_Collapsed;
            }

            Current = t;
            if (_currentTask.Count == 0)
            {
                _currentTask.Add(t);
            }
            else
            {
                _currentTask[0] = t;
            }

            // Make visible the timer for the current task.
            _currentTask[0].TimerVisible = Resources.Visibility_Visible;
            // Toggle the timer
            TaskTimer.ToggleStartStop();

            // No need to toggle the start Checkbox since binding

            // TODO: Where should this be setted to false?
            TaskHasStarted = true;

            // Hides the play/pause button for all the task except Current.
            foreach (var i in _repository.GetCollection())
            {
                if (i.ID != Current.ID)
                {
                    i.TogglePlayAndPauseButtonsVisibility();
                }
            }
        }

        /// <summary>
        /// Cleans the comboboxes to default state.
        /// </summary>
        void SetComboboxToDefault()
        {
            // TODO:  Check that has items before indexing
            //Priority = TaskPriorityItems[0];
            Priority = Resources.TaskPriority_Normal;
            Category = Resources.Category_NoCategory;
        }

        /// <summary>
        /// Toggles between Visible and Hidden. Allows to hide Play and Pause buttons of all the task
        /// that aren't currently "running".
        /// </summary>
        void TogglePlayAndPauseButtonsVisibility()
        {
            if (PlayPauseIsVisible == Resources.Visibility_Visible)
            {
                PlayPauseIsVisible = Resources.Visibility_Hidden;
            }
            else
            {
                PlayPauseIsVisible = Resources.Visibility_Visible;
            }
        }

        /// <summary>
        /// Function passed to the TaskTimer to be called on each tick and allow us to update
        /// this property to the View.
        /// </summary>
        void FetchTimer()
        {
            Current.OnPropertyChanged("Timer");
        }

        void TestDialog(string message)
        {
            MessageBox.Show(message);
        }

        #endregion // Helper Methods

        #region Interface Implementations

        string IDataErrorInfo.this[string columnName]
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        string IDataErrorInfo.Error
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        string IPageViewModel.Name
        {
            get { return "Add Task"; }
            set { }
        }

        public string HasVisibleButton
        {
            get { return Resources.Visibility_Visible; }
            set { }
        }

        public string Normal
        {
            get { return "Resources/Buttons/AddTask.png"; }
        }

        public string Hover
        {
            get { return "Resources/Buttons/AddTaskHover.png"; }
        }

        public string Clicked
        {
            get { return "Resources/Buttons/AddTaskClicked.png"; }
        }

        public string Selected
        {
            get { return ""; }
        }

        public string Height
        {
            get { return "24"; }
            set { }
        }

        public string Width
        {
            get { return "82"; }
            set { }
        }

        #endregion // Interface Implementations

        #region Overrides

        public override string ToString()
        {
            /*var str = String.Format
                ("ID: " + ID +
                 "\nName: " + Name +
                 "\nContent: " + Content +
                 "\nCategory: " + Category +
                 "\nPomodoros" + Pomodoros +
                 "\nIsBookmark: " + IsBookmark +
                 "\nPriority: " + TaskPriority);*/
            var str = "ID: " + ID +
                      "\nName: " + Name +
                      "\nContent: " + Content +
                      "\nCategory: " + Category +
                      "\nPomodoros: " + Pomodoros +
                      "\nIsBookmark: " + IsBookmark +
                      "\nPriority: " + TaskPriority;
            return str;
        }

        #endregion // Overrides
    }
}
